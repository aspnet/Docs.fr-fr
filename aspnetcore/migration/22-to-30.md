---
title: Migrer de ASP.NET Core 2,2 à 3,0
author: rick-anderson
description: Découvrez comment migrer un projet ASP.NET Core 2,2 vers ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 2f8602dd1356fdc5a224545805da9532426c6dec
ms.sourcegitcommit: 8b0e9a72c1599ce21830c843558a661ba908ce32
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "98024806"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrer de ASP.NET Core 2,2 à 3,0

Par [Scott Addie](https://github.com/scottaddie) et [Rick Anderson](https://twitter.com/RickAndMSFT)

Cet article explique comment mettre à jour un projet ASP.NET Core 2,2 existant vers ASP.NET Core 3,0. Il peut être utile de créer un nouveau ASP.NET Core projet 3,0 pour :

* Comparez avec le code ASP.NET Core 2,2.
* Copiez les modifications correspondantes dans votre projet ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prérequis

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio pour Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Mettre à jour la version du SDK .NET Core dans global.json

Si votre solution repose [ sur unglobal.jssur](/dotnet/core/tools/global-json) un fichier pour cibler une version de kit SDK .net Core spécifique, mettez à jour sa `version` propriété sur la version 3,0 installée sur votre ordinateur :

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Mettre à jour le fichier projet

### <a name="update-the-target-framework"></a>Mettre à jour la version cible de .NET Framework

ASP.NET Core 3,0 et versions ultérieures s’exécutent uniquement sur .NET Core. Définissez le [moniker du Framework cible (TFM)](/dotnet/standard/frameworks) sur `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Supprimer les références de package obsolètes

Un grand nombre de packages NuGet ne sont pas générés pour ASP.NET Core 3,0. Ces références de package doivent être supprimées de votre fichier projet. Considérez le fichier projet suivant pour une application Web ASP.NET Core 2,2 :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Le fichier projet mis à jour pour ASP.NET Core 3,0 :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Fichier de projet ASP.NET Core 3,0 mis à jour :

* Dans le `<PropertyGroup>` :
  * Met à jour le TFM à `netcoreapp3.0`
  * Supprime l' `<AspNetCoreHostingModel>` élément. Pour plus d’informations, consultez [modèle d’hébergement in-process](#in-process-hosting-model) dans ce document.

* Dans le `<ItemGroup>` :
  * `Microsoft.AspNetCore.App` est supprimé. Pour plus d’informations, consultez Référence de l' [infrastructure](#framework-reference) dans ce document.
  * `Microsoft.AspNetCore.Razor.Design` est supprimé et la liste suivante des packages n’est plus produite.

Pour afficher la liste complète des packages qui ne sont plus produits, sélectionnez la liste de développement suivante :

<details>
    <summary>Cliquez pour développer la liste des packages qui ne sont plus produits.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft. AspNetCore. Authentication. Cookie x</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft. AspNetCore. Cookie Renvoi</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. AspNetCore. Mvc.Razor</li>
        <li>Microsoft. AspNetCore. Mvc. Razor . ViewCompilation</li>
        <li>Microsoft. AspNetCore. Mvc. Razor Pages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. AspNetCore.Razor</li>
        <li>Microsoft. AspNetCore. Razor . Language</li>
        <li>Microsoft. AspNetCore. Razor . Nomination</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore. SignalR . Ebauche</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Examiner les modifications avec rupture

[Examiner les modifications avec rupture](#break)

### <a name="framework-reference"></a>Référence du Framework

Les fonctionnalités de ASP.NET Core qui étaient disponibles via l’un des packages répertoriés ci-dessus sont disponibles dans le cadre de l' `Microsoft.AspNetCore.App` infrastructure partagée. L' *infrastructure partagée* est l’ensemble d’assemblys (fichiers *. dll* ) qui sont installés sur l’ordinateur et comprend un composant d’exécution et un pack de ciblage. Pour plus d’informations, consultez [Le framework partagé](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Les projets qui ciblent le `Microsoft.NET.Sdk.Web` Kit de développement logiciel (SDK) référencent implicitement le `Microsoft.AspNetCore.App` Framework.

  Aucune référence supplémentaire n’est requise pour ces projets :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Les projets qui ciblent `Microsoft.NET.Sdk` ou le `Microsoft.NET.Sdk.Razor` Kit de développement logiciel (SDK) doivent ajouter un explicite `FrameworkReference` à `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Builds dépendantes du Framework utilisant l’ancrage

Les builds dépendantes du Framework des applications console qui utilisent un package qui dépend de l' [infrastructure partagée](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.net Core peuvent fournir l’erreur d’exécution suivante :

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` est le Framework partagé contenant le runtime ASP.NET Core et est uniquement présent sur l’image de l’ancrage [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) . Le kit de développement logiciel (SDK) 3,0 réduit la taille des builds dépendantes du Framework à l’aide de ASP.NET Core en n’incluant pas de copies en double des bibliothèques disponibles dans le Framework partagé. Il s’agit d’une économie potentielle de 18 Mo, mais cela nécessite que le runtime ASP.NET Core soit présent/installé pour exécuter l’application.

Pour déterminer si l’application a une dépendance (directe ou indirecte) sur le ASP.NET Core Framework partagé, examinez le *runtimeconfig.jssur* le fichier généré pendant une génération/publication de votre application. Le fichier JSON suivant illustre une dépendance sur le ASP.NET Core Framework partagé :

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Si votre application utilise la station d’accueil, utilisez une image de base qui comprend ASP.NET Core 3,0. Par exemple : `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Ajouter des références de package pour les assemblys supprimés

ASP.NET Core 3,0 supprime certains assemblys qui faisaient auparavant partie de la `Microsoft.AspNetCore.App` Référence du package. Pour visualiser les assemblys qui ont été supprimés, comparez les deux dossiers d’infrastructure partagés. Par exemple, une comparaison des versions 2.2.7 et 3.0.0 :

![Comparaison des assemblys d’infrastructure partagée](22-to-30/_static/assembly-diff.png)

Pour continuer à utiliser les fonctionnalités fournies par les assemblys supprimés, référencez les versions 3,0 des packages correspondants :

* Une application Web générée par modèle avec des **comptes d’utilisateur individuels** nécessite l’ajout des packages suivants :

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Pour plus d’informations sur le référencement du package spécifique au fournisseur de base de données, consultez [fournisseurs de bases de données](/ef/core/providers/index).

* Interface utilisateur du service Identity

  La prise en charge de l' [ Identity interface utilisateur](xref:security/authentication/identity) peut être ajoutée en référençant [Microsoft. AspNetCore. Identity Package d’interface utilisateur](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Services SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Authentification : la prise en charge des flux d’authentification tiers est disponible sous forme de packages NuGet :

  * OAuth Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Authentification de compte Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Authentification OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Jeton du porteur OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Authentification WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Prise en charge de la mise en forme et de la négociation du contenu pour `System.Net.HttpClient` : le package NuGet [Microsoft. Aspnet. WebApi. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) offre une extensibilité utile `System.Net.HttpClient` avec les API telles que `ReadAsAsync` et `PostJsonAsync` .

* Razor compilation du Runtime : la prise en charge de la compilation du runtime des Razor affichages et des pages fait désormais partie de [Microsoft. AspNetCore. Mvc. Razor RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* `Newtonsoft.Json`Prise en charge de MVC (JSON.net) : la prise en charge de l’utilisation de MVC avec `Newtonsoft.Json` est désormais intégrée à [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>Modifications au démarrage

L’illustration suivante montre les lignes supprimées et modifiées dans une Razor application Web ASP.NET Core 2,2 pages :

![lignes supprimées et modifiées dans une ASP.NET Core 2,2 ::: No-Loc (Razor) ::: Web App](22-to-30/_static/startup2.2.png)

Dans l’image précédente, le code supprimé est affiché en rouge. Le code supprimé n’affiche pas le cookie code d’options, qui a été supprimé avant la comparaison des fichiers.

L’illustration suivante montre les lignes ajoutées et modifiées dans une Razor application Web ASP.NET Core 3,0 pages :

![lignes ajoutées et modifiées dans une ASP.NET Core 3,0 ::: No-Loc (Razor) ::: Web App](22-to-30/_static/startup3.0.png)

Dans l’image précédente, le code ajouté est affiché en vert. Pour plus d’informations sur les modifications suivantes :

* `services.AddMvc` pour `services.AddRazorPages` , consultez [inscription du service MVC](#mvc-service-registration) dans ce document.
* `CompatibilityVersion`, consultez <xref:mvc/compatibility-version> .
* `IHostingEnvironment` pour `IWebHostEnvironment` , consultez [cette annonce GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` a été ajouté aux modèles pour montrer que l’intergiciel d’autorisation de commande doit être ajouté. Si l’application n’utilise pas l’autorisation, vous pouvez supprimer en toute sécurité l’appel à `app.UseAuthorization` .
* `app.UseEndpoints`, consultez [ Razor pages](#razor-pages) ou [migrer Startup.Configurer](#migrate-startupconfigure) dans ce document.

### <a name="analyzer-support"></a>Prise en charge de l’analyseur

Les projets qui ciblent `Microsoft.NET.Sdk.Web` implicitement des analyseurs de référence ont été fournis précédemment dans le cadre du package [Microsoft. AspNetCore. Mvc. Analysis](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Aucune référence supplémentaire n’est requise pour les activer.

Si votre application utilise des [analyseurs d’API](xref:web-api/advanced/analyzers) livrés précédemment à l’aide du package [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , modifiez votre fichier projet pour référencer les analyseurs fournis dans le cadre du kit de développement logiciel (SDK) Web .net Core :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="no-locrazor-class-library"></a>Razor Bibliothèque de classes

Razor Les projets de bibliothèque de classes qui fournissent des composants d’interface utilisateur pour MVC doivent définir la `AddRazorSupportForMvc` propriété dans le fichier projet :

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modèle d’hébergement in-process

Les projets sont par défaut du [modèle d’hébergement in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) dans ASP.net Core 3,0 ou version ultérieure. Vous pouvez éventuellement supprimer la `<AspNetCoreHostingModel>` propriété dans le fichier projet si sa valeur est `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuration

Migrer la configuration Kestrel vers le [Générateur d’hôte Web](#hostb) fourni par `ConfigureWebHostDefaults` (*Program.cs*) :

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si l’application crée l’hôte manuellement avec `ConfigureWebHost` au lieu de `ConfigureWebHostDefaults` , appelez `UseKestrel` sur le générateur d’hôte Web :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>L’intergiciel de connexion remplace les adaptateurs de connexion

Les adaptateurs de connexion ( `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` ) ont été supprimés de Kestrel. Remplacer les adaptateurs de connexion par un intergiciel de connexion. L’intergiciel de connexion est similaire à l’intergiciel (middleware) HTTP dans le pipeline ASP.NET Core, mais pour les connexions de niveau inférieur. Journalisation HTTPs et connexion :

* Ont été déplacés des adaptateurs de connexion vers l’intergiciel de connexion.
* Ces méthodes d’extension fonctionnent comme dans les versions précédentes de ASP.NET Core. 

Pour plus d’informations, consultez [l’exemple TlsFilterConnectionHandler dans la section ListenOptions. Protocols de l’article Kestrel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstractions de transport déplacées et rendues publiques

La couche de transport Kestrel a été exposée en tant qu’interface publique dans `Connections.Abstractions` . Dans le cadre de ces mises à jour :

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` et les types associés ont été supprimés.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> a été déplacé de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> vers les options de transport.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` a été supprimé de <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

Pour plus d’informations, consultez les ressources GitHub suivantes :

* [Abstractions de réseau client/serveur (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implémenter l’abstraction de l’écouteur socle et plat Kestrel en haut (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>En-têtes de la demande Kestrel

Pour les applications qui ciblent des versions antérieures de ASP.NET Core :

* Kestrel ajoute des en-têtes de code de fin en bloc HTTP/1.1 dans la collection d’en-têtes de demande.
* Les codes de fin sont disponibles une fois que le corps de la demande est lu jusqu’à la fin.

Cela pose des problèmes d’ambiguïté entre les en-têtes et les codes de fin, de sorte que les codes de fin ont été déplacés vers une nouvelle collection ( `RequestTrailerExtensions` ) en 3,0.

Les codes de fin de requête HTTP/2 sont :

* Non disponible dans ASP.NET Core 2,2.
* Disponible dans 3,0 en tant que `RequestTrailerExtensions` .

De nouvelles méthodes d’extension de demande sont présentes pour accéder à ces codes de fin. Comme avec HTTP/1.1, les codes de fin sont disponibles une fois que le corps de la demande est lu jusqu’à la fin.

Pour la version 3,0, les `RequestTrailerExtensions` méthodes suivantes sont disponibles :

* `GetDeclaredTrailers`: Obtient l' `Trailer` en-tête de la demande qui répertorie les codes de fin à attendre après le corps.
* `SupportsTrailers`: Indique si la demande prend en charge la réception des en-têtes de code de fin.
* `CheckTrailersAvailable`: Vérifie si la demande prend en charge les codes de fin et s’ils sont disponibles pour la lecture. Cette vérification ne suppose pas qu’il y a des codes de fin à lire. Il se peut qu’il n’y ait aucune remorque à lire même si `true` est retourné par cette méthode.
* `GetTrailer`: Obtient l’en-tête de fin demandé de la réponse. Vérifiez `SupportsTrailers` avant `GetTrailer` d’appeler, ou un <xref:System.NotSupportedException> peut se produire si la requête ne prend pas en charge les en-têtes de fin.

Pour plus d’informations, consultez [put Request queues in a distinct collection (dotnet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO désactivé

`AllowSynchronousIO` active ou désactive les API d’e/s synchrones, telles que `HttpRequest.Body.Read` , `HttpResponse.Body.Write` et `Stream.Flush` . Ces API sont une source de privation de thread conduisant à des blocages d’application. Dans 3,0, `AllowSynchronousIO` est désactivé par défaut. Pour plus d’informations, consultez [la section e/s synchrones dans l’article Kestrel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#synchronous-io).

Si des e/s synchrones sont nécessaires, vous pouvez les activer en configurant l' `AllowSynchronousIO` option sur le serveur utilisé (lors `ConfigureKestrel` de l’appel de, par exemple, si vous utilisez Kestrel). Notez que les serveurs (Kestrel, HttpSys, TestServer, etc.) ont leur propre `AllowSynchronousIO` option qui n’affectera pas les autres serveurs. Les e/s synchrones peuvent être activées pour tous les serveurs par demande à l’aide de l' `IHttpBodyControlFeature.AllowSynchronousIO` option :

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si vous avez des difficultés avec les <xref:System.IO.TextWriter> implémentations ou d’autres flux qui appellent des API synchrones dans [dispose](/dotnet/standard/garbage-collection/implementing-dispose), appelez plutôt la nouvelle <xref:System.IO.Stream.DisposeAsync*> API.

Pour plus d’informations, consultez [[Announcement] AllowSynchronousIO disabled in All Servers (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="output-formatter-buffering"></a>Mise en mémoire tampon du formateur de sortie

[Newtonsoft.Jssur](https://www.newtonsoft.com/json), <xref:System.Xml.Serialization.XmlSerializer> et les <xref:System.Runtime.Serialization.DataContractSerializer> formateurs de sortie basés sur, et prennent uniquement en charge la sérialisation synchrone. Pour permettre à ces formateurs de fonctionner avec les restrictions [AllowSynchronousIO](https://github.com/dotnet/aspnetcore/issues/7644) du serveur, MVC met en mémoire tampon la sortie de ces formateurs avant l’écriture sur le disque. En raison de la mise en mémoire tampon, MVC inclut l’en-tête Content-Length lors de la réponse à l’aide de ces formateurs.

<xref:System.Text.Json> prend en charge la sérialisation asynchrone et, par conséquent, le `System.Text.Json` formateur de base ne met pas en mémoire tampon. Envisagez d’utiliser ce formateur pour améliorer les performances.

Pour désactiver la mise en mémoire tampon, les applications peuvent configurer <xref:Microsoft.AspNetCore.Mvc.MvcOptions.SuppressOutputFormatterBuffering> au démarrage :

```csharp
services.AddControllers(options => options.SuppressOutputFormatterBuffering = true)
```

Notez que cela peut entraîner la levée d’une exception d’exécution par l’application si `AllowSynchronousIO` n’est pas également configuré.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. Kestrel. https supprimé

Dans ASP.NET Core 2,1, le contenu de *Microsoft.AspNetCore.Server.Kestrel.Https.dll* a été déplacé vers *Microsoft.AspNetCore.Server.Kestrel.Core.dll*. Il s’agissait d’une mise à jour sans rupture utilisant des `TypeForwardedTo` attributs. Pour 3,0, l’assembly *Microsoft.AspNetCore.Server.Kestrel.Https.dll* vide et le package NuGet ont été supprimés.

Les bibliothèques référençant [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) doivent mettre à jour les dépendances de ASP.NET Core à 2,1 ou une version ultérieure.

Les applications et les bibliothèques qui ciblent ASP.NET Core 2,1 ou version ultérieure doivent supprimer toutes les références directes au package [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Prise en charge de Newtonsoft.Js(Json.NET)

Dans le cadre du travail d' [amélioration du ASP.net Core Framework partagé](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Newtonsoft.Js(JSON.net)](https://www.newtonsoft.com/json/help/html/Introduction.htm) a été supprimé de la ASP.net Core Framework partagé.

Le sérialiseur JSON par défaut pour ASP.NET Core est désormais <xref:System.Text.Json> , qui est nouveau dans .net Core 3,0. Envisagez d’utiliser dans la `System.Text.Json` mesure du possible. Elle est très performante et ne nécessite pas de dépendance de bibliothèque supplémentaire. Toutefois, étant donné que `System.Text.Json` est nouveau, il est possible qu’il manque actuellement des fonctionnalités dont votre application a besoin. Pour plus d’informations, consultez [Comment migrer à partir de Newtonsoft.Jssur System.Text.Jssur](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-no-locsignalr-project"></a>Utilisez Newtonsoft.Jssur dans un projet ASP.NET Core 3,0 SignalR

* Installez [Microsoft. AspNetCore. SignalR . Package NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .

* Sur le client, chaînez un `AddNewtonsoftJsonProtocol` appel de méthode à l' `HubConnectionBuilder` instance :

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chathub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Sur le serveur, chaînez un `AddNewtonsoftJsonProtocol` appel de méthode à l' `AddSignalR` appel de méthode dans `Startup.ConfigureServices` :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Utilisez Newtonsoft.Jssur dans un projet MVC ASP.NET Core 3,0

* Installez le [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Package.

* Mettez à jour `Startup.ConfigureServices` pour appeler `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` est compatible avec les nouvelles méthodes d’inscription de service MVC :

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json` les paramètres peuvent être définis dans l’appel à `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

  **Remarque :** Si la `AddNewtonsoftJson` méthode n’est pas disponible, assurez-vous que vous avez installé le [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Package. Une erreur courante consiste à installer le [Newtonsoft.Jssur](https://www.nuget.org/packages/Newtonsoft.Json/) le package à la place du [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Package.

Pour plus d’informations, consultez [ajouter Newtonsoft.Jsprise en charge du format JSON basé sur](xref:web-api/advanced/formatting#add-newtonsoftjson-based-json-format-support).

## <a name="mvc-service-registration"></a>Inscription du service MVC

ASP.NET Core 3,0 ajoute de nouvelles options pour l’inscription de scénarios MVC dans `Startup.ConfigureServices` .

Trois nouvelles méthodes d’extension de niveau supérieur liées aux scénarios MVC sur `IServiceCollection` sont disponibles. Les modèles utilisent ces nouvelles méthodes à la place de `AddMvc` . Toutefois, `AddMvc` continue à se comporter comme dans les versions précédentes.

L’exemple suivant ajoute la prise en charge des contrôleurs et des fonctionnalités liées à l’API, mais pas aux vues ou aux pages. Le modèle d’API utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

L’exemple suivant ajoute la prise en charge des contrôleurs, des fonctionnalités liées à l’API et des vues, mais pas des pages. Le modèle d’application Web (MVC) utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

L’exemple suivant ajoute la prise en charge des Razor pages et une prise en charge minimale du contrôleur. Le modèle d’application Web utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Les nouvelles méthodes peuvent également être combinées. L’exemple suivant est équivalent à l’appel `AddMvc` de dans ASP.NET Core 2,2 :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routage du code de démarrage

Si une application appelle `UseMvc` ou `UseSignalR` , migrez l’application vers le [routage des points de terminaison](xref:fundamentals/routing) , si possible. Pour améliorer la compatibilité du routage des points de terminaison avec les versions précédentes de MVC, nous avons rétabli certaines des modifications apportées à la génération d’URL introduites dans ASP.NET Core 2,2. Si vous avez rencontré des problèmes lors de l’utilisation du routage de point de terminaison dans 2,2, attendez-vous à des améliorations de ASP.NET Core 3,0, avec les exceptions suivantes :

* Si l’application implémente `IRouter` ou hérite de `Route` , utilisez [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) comme remplacement.
* Si l’application accède directement `RouteData.Routers` à MVC pour analyser des URL, vous pouvez la remplacer par l’utilisation de [LinkParser. ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Définissez l’itinéraire avec un nom d’itinéraire.
  * Utilisez `LinkParser.ParsePathByEndpointName` et transmettez le nom de l’itinéraire souhaité.

Le routage des points de terminaison prend en charge les mêmes syntaxe de modèle d’itinéraire et fonctionnalités de création de modèle de routage que `IRouter` . Le routage des points de terminaison prend en charge `IRouteConstraint` . Le routage des points de terminaison prend en charge `[Route]` , `[HttpGet]` et les autres attributs de routage Mvc.

Pour la plupart des applications, nécessite uniquement des `Startup` modifications.

### <a name="migrate-startupconfigure"></a>Migrer Startup.Configurer

Conseils généraux :

* Ajoutez `UseRouting`.
* Si l’application appelle `UseStaticFiles` , placez-la `UseStaticFiles` **avant** `UseRouting` .
* Si l’application utilise des fonctionnalités d’authentification/d’autorisation telles que `AuthorizePage` ou `[Authorize]` , placez l’appel à `UseAuthentication` et `UseAuthorization` : **après**, `UseRouting` et `UseCors` , mais avant `UseEndpoints` :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Remplacez `UseMvc` ou `UseSignalR` par `UseEndpoints` .
* Si l’application utilise des scénarios [cors](xref:security/cors) , tels que `[EnableCors]` , placez l’appel à `UseCors` avant tout autre intergiciel qui utilise cors (par exemple, placez `UseCors` avant `UseAuthentication` , `UseAuthorization` et `UseEndpoints` ).
* Remplacez `IHostingEnvironment` par `IWebHostEnvironment` et ajoutez une `using` instruction pour l' <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espace de noms.
* Remplacez `IApplicationLifetime` par <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espace de noms).
* Remplacez `EnvironmentName` par <xref:Microsoft.Extensions.Hosting.Environments> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espace de noms).

Le code suivant est un exemple de `Startup.Configure` dans une application ASP.NET Core 2,2 standard :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Après la mise à jour du `Startup.Configure` code précédent :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pour la plupart des applications, `UseAuthentication` les appels à, `UseAuthorization` et `UseCors` doivent apparaître entre les appels à `UseRouting` et `UseEndpoints` pour être effectifs.

### <a name="health-checks"></a>Contrôles d'intégrité

Les contrôles d’intégrité utilisent le routage de point de terminaison avec l’hôte générique. Dans `Startup.Configure` , appelez `MapHealthChecks` sur le générateur de points de terminaison avec l’URL de point de terminaison ou le chemin d’accès relatif :

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Les points de terminaison de contrôle d’intégrité peuvent :

* Spécifiez un ou plusieurs hôtes/ports autorisés.
* Exiger une autorisation.
* Exiger CORS.

Pour plus d'informations, consultez <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Aide sur le middleware de sécurité

La prise en charge de l’autorisation et de CORS est unifiée autour de l’approche de l' [intergiciel (middleware](xref:fundamentals/middleware/index) ). Cela permet d’utiliser les mêmes intergiciels et fonctionnalités dans ces scénarios. Un intergiciel (middleware) d’autorisation mis à jour est fourni dans cette version, et l’intergiciel (middleware) CORS est amélioré afin de pouvoir comprendre les attributs utilisés par les contrôleurs MVC.

#### <a name="cors"></a>CORS

Auparavant, CORS pouvait être difficile à configurer. L’intergiciel était fourni pour une utilisation dans certains cas d’utilisation, mais les filtres MVC devaient être utilisés **sans** l’intergiciel dans d’autres cas d’usage. Avec ASP.NET Core 3,0, nous recommandons que toutes les applications qui requièrent CORS utilisent l’intergiciel (middleware) CORS en tandem avec le routage du point de terminaison. `UseCors` peut être fourni avec une stratégie par défaut, et les `[EnableCors]` `[DisableCors]` attributs et peuvent être utilisés pour remplacer la stratégie par défaut si nécessaire.

Dans l’exemple suivant :

* CORS est activé pour tous les points de terminaison avec la `default` stratégie nommée.
* La `MyController` classe désactive cors avec l' `[DisableCors]` attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorisation

Dans les versions antérieures de ASP.NET Core, la prise en charge de l’autorisation a été fournie via l' `[Authorize]` attribut. L’intergiciel d’autorisation n’est pas disponible. Dans ASP.NET Core 3,0, l’intergiciel (middleware) d’autorisation est requis. Nous vous recommandons de placer le ASP.NET Core middleware d’autorisation ( `UseAuthorization` ) immédiatement après `UseAuthentication` . L’intergiciel d’autorisation peut également être configuré avec une stratégie par défaut, qui peut être remplacée.

Dans ASP.NET Core 3,0 ou version ultérieure, `UseAuthorization` est appelé dans `Startup.Configure` , et les éléments suivants `HomeController` requièrent un utilisateur connecté :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Lorsque vous utilisez le routage de point de terminaison, nous vous recommandons `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` de configurer et de s’appuyer plutôt sur l’intergiciel d’autorisation.  Si l’application utilise un `AuthorizeFilter` comme filtre global dans MVC, nous vous recommandons de refactoriser le code pour fournir une stratégie dans l’appel à `AddAuthorization` .

Le `DefaultPolicy` est initialement configuré pour exiger une authentification, de sorte qu’aucune configuration supplémentaire n’est requise. Dans l’exemple suivant, les points de terminaison MVC sont marqués comme `RequireAuthorization` afin que toutes les requêtes doivent être autorisées en fonction du `DefaultPolicy` . Toutefois, le `HomeController` autorise l’accès sans que l’utilisateur se connecte à l’application en raison des `[AllowAnonymous]` éléments suivants :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorisation pour des points de terminaison spécifiques

L’autorisation peut également être configurée pour des classes spécifiques de points de terminaison. Le code suivant est un exemple de conversion d’une application MVC qui a configuré une application globale `AuthorizeFilter` pour une application avec une stratégie spécifique nécessitant une autorisation :

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Les stratégies peuvent également être personnalisées. Le `DefaultPolicy` est configuré pour exiger l’authentification :

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Sinon, tous les points de terminaison peuvent être configurés pour exiger `[Authorize]` l’autorisation sans ou `RequireAuthorization` en configurant un `FallbackPolicy` . `FallbackPolicy`Est différent de `DefaultPolicy` . `DefaultPolicy`Est déclenché par `[Authorize]` ou `RequireAuthorization` , tandis que `FallbackPolicy` est déclenché quand aucune autre stratégie n’est définie. `FallbackPolicy` est initialement configuré pour autoriser les demandes sans autorisation.

L’exemple suivant est identique à l’exemple précédent, `DefaultPolicy` mais utilise `FallbackPolicy` pour toujours exiger l’authentification sur tous les points de terminaison sauf si `[AllowAnonymous]` est spécifié :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

L’autorisation par intergiciel fonctionne sans que l’infrastructure ait une connaissance spécifique de l’autorisation. Par exemple, les [contrôles d’intégrité](xref:host-and-deploy/health-checks) n’ont aucune connaissance spécifique de l’autorisation, mais les contrôles d’intégrité peuvent avoir une stratégie d’autorisation configurable appliquée par l’intergiciel (middleware).

En outre, chaque point de terminaison peut personnaliser ses exigences d’autorisation. Dans l’exemple suivant, `UseAuthorization` traite l’autorisation avec `DefaultPolicy` , mais le `/healthz` point de terminaison de contrôle d’intégrité requiert un `admin` utilisateur :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protection est implémentée pour certains scénarios. L’intergiciel (middleware) de points de terminaison lève une exception si une stratégie d’autorisation ou CORS est ignorée en raison d’un intergiciel (middleware) manquant. La prise en charge de l’analyseur pour fournir des commentaires supplémentaires sur une configuration incompatible est en cours.

#### <a name="custom-authorization-handlers"></a>Gestionnaires d’autorisations personnalisés

Si l’application utilise des [gestionnaires d’autorisations](xref:security/authorization/policies#authorization-handlers)personnalisés, le routage des points de terminaison passe un type de ressource différent aux gestionnaires que Mvc. Les gestionnaires qui s’attendent à ce que la ressource de contexte du gestionnaire d’autorisations soit de type <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (le type de ressource [fourni par les filtres MVC](xref:security/authorization/policies#access-mvc-request-context-in-handlers)) devront être mis à jour pour gérer les ressources de type <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (le type de ressource donné aux gestionnaires d’autorisation par le routage de point de terminaison).

MVC utilise toujours des `AuthorizationFilterContext` ressources. ainsi, si l’application utilise des filtres d’autorisation MVC avec l’autorisation de routage de point de terminaison, il peut être nécessaire de gérer les deux types de ressources.

### SignalR

Le mappage des SignalR hubs a désormais lieu à l’intérieur de `UseEndpoints` .

Mappez chaque concentrateur avec `MapHub` . Comme dans les versions précédentes, chaque concentrateur est explicitement listé.

Dans l’exemple suivant, la prise en charge du `ChatHub` SignalR Hub est ajoutée :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Une nouvelle option permet de contrôler les limites de taille des messages des clients. Par exemple, dans `Startup.ConfigureServices` :

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

Dans ASP.NET Core 2,2, vous pouviez définir la valeur `TransportMaxBufferSize` et pour contrôler la taille de message maximale. Dans ASP.NET Core 3,0, cette option contrôle désormais uniquement la taille maximale avant que la contre-pression soit observée.

### <a name="mvc-controllers"></a>Contrôleurs MVC

Le mappage de contrôleurs a désormais lieu à l’intérieur de `UseEndpoints` .

Ajoutez `MapControllers` si l’application utilise le routage d’attributs. Dans la mesure où le routage inclut la prise en charge de nombreuses infrastructures dans ASP.NET Core 3,0 ou version ultérieure, l’ajout de contrôleurs routés par attribut est un abonnement.

Remplacez le code suivant :

* `MapRoute` avec `MapControllerRoute`
* `MapAreaRoute` avec `MapAreaControllerRoute`

Étant donné que le routage inclut désormais une prise en charge de plus que MVC, la terminologie a changé pour indiquer clairement ce qu’ils font. Les itinéraires conventionnels tels que `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` sont appliqués dans l’ordre dans lequel ils sont ajoutés. Placez d’abord des itinéraires plus spécifiques (tels que des itinéraires pour une zone).

Dans l’exemple suivant :

* `MapControllers` Ajoute la prise en charge des contrôleurs routés par attribut.
* `MapAreaControllerRoute` Ajoute une route conventionnelle pour les contrôleurs dans une zone.
* `MapControllerRoute` Ajoute une route conventionnelle pour les contrôleurs.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Suppression du suffixe Async des noms d’action du contrôleur

Dans ASP.NET Core 3,0, ASP.NET Core MVC supprime le `Async` suffixe des noms d’action du contrôleur. Le routage et la génération de liens sont affectés par cette nouvelle valeur par défaut. Par exemple :

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Avant ASP.NET Core 3,0 :

* L’action précédente est accessible à l’itinéraire *Products/ListAsync* .
* Génération de lien requise spécifiant le `Async` suffixe. Par exemple :

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

Dans ASP.NET Core 3,0 :

* L’action précédente est accessible à l’itinéraire *Products/List* .
* La génération de liens ne nécessite pas la spécification du `Async` suffixe. Par exemple :

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Cette modification n’affecte pas les noms spécifiés à l’aide de l' [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) attribut. Le comportement par défaut peut être désactivé avec le code suivant dans `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Modifications apportées à la génération de liens

Comme expliqué dans la documentation sur les [différences par rapport aux versions antérieures du routage](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), il existe quelques différences dans la génération de liens (à l’aide `Url.Link` de et d’API similaires, par exemple). Il s’agit, entre autres, des suivantes :

* Par défaut, lors de l’utilisation du routage de point de terminaison, la casse des paramètres d’itinéraire dans les URI générés n’est pas nécessairement préservée. Ce comportement peut être contrôlé avec l' `IOutboundParameterTransformer` interface.
* La génération d’un URI pour un itinéraire non valide (un contrôleur/une action ou une page qui n’existe pas) produira une chaîne vide sous le routage de point de terminaison au lieu de produire un URI non valide.
* Les valeurs ambiantes (paramètres d’itinéraire du contexte actuel) ne sont pas utilisées automatiquement dans la génération de liens avec le routage de point de terminaison. Précédemment, lors de la génération d’un lien vers une autre action (ou page), les valeurs d’itinéraire non spécifiées seraient déduites des valeurs ambiantes des itinéraires *actuels* . Lorsque vous utilisez le routage de point de terminaison, tous les paramètres de routage doivent être spécifiés explicitement lors de la génération de liens.

### <a name="no-locrazor-pages"></a>Razor Pages

Les pages de mappage ont Razor maintenant lieu dans `UseEndpoints` .

Ajoutez `MapRazorPages` si l’application utilise des Razor pages. Dans la mesure où le routage des points de terminaison inclut la prise en charge de nombreuses infrastructures, l’ajout de Razor pages est maintenant en cours d’abonnement.

Dans la `Startup.Configure` méthode suivante, `MapRazorPages` ajoute la prise en charge des Razor pages :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Utiliser MVC sans routage de point de terminaison

L’utilisation de MVC via `UseMvc` ou `UseMvcWithDefaultRoute` dans ASP.net Core 3,0 requiert un abonnement explicite à l’intérieur de `Startup.ConfigureServices` . Cela est nécessaire, car MVC doit savoir s’il peut reposer sur l’autorisation et l’intergiciel CORS pendant l’initialisation. Un analyseur est fourni pour avertir si l’application tente d’utiliser une configuration non prise en charge.

Si l’application nécessite `IRouter` une prise en charge héritée, désactivez `EnableEndpointRouting` l’une des approches suivantes dans `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Contrôles d’intégrité

Les contrôles d’intégrité peuvent être utilisés en tant que *routeur* avec routage des points de terminaison.

Ajoutez `MapHealthChecks` pour utiliser les vérifications d’intégrité avec routage du point de terminaison. La `MapHealthChecks` méthode accepte des arguments similaires à `UseHealthChecks` . L’avantage de l’utilisation de la valeur `MapHealthChecks` `UseHealthChecks` on est la possibilité d’appliquer une autorisation et d’avoir un contrôle plus précis de la stratégie de correspondance.

Dans l’exemple suivant, `MapHealthChecks` est appelé pour un point de terminaison de contrôle d’intégrité sur `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder remplace WebHostBuilder

Les modèles ASP.NET Core 3,0 utilisent l' [hôte générique](xref:fundamentals/host/generic-host). Les versions précédentes utilisaient l' [hôte Web](xref:fundamentals/host/web-host). Le code suivant illustre la classe générée par le modèle ASP.NET Core 3,0 `Program` :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Le code suivant illustre la classe ASP.NET Core 2,2 générée par le modèle `Program` :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> reste dans 3,0 et est le type de la `webBuilder` vue dans l’exemple de code précédent. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> sera dépréciée dans une version ultérieure et remplacée par `HostBuilder` .

La modification la plus significative de `WebHostBuilder` en `HostBuilder` est l' [injection de dépendances (di)](xref:fundamentals/dependency-injection). Lorsque `HostBuilder` vous utilisez, vous pouvez uniquement injecter le `Startup` constructeur suivant :

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder`Contraintes di :

* Autorisez la génération du conteneur DI une seule fois.
* Évite les problèmes de durée de vie des objets résultants, tels que la résolution de plusieurs instances de singletons.

Pour plus d’informations, consultez [prévention de l’injection du service de démarrage dans ASP.net Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization déplacé vers un autre assembly

Les méthodes ASP.NET Core 2,2 et Lower `AddAuthorization` dans *Microsoft.AspNetCore.Authorization.dll*:

* Ont été renommés `AddAuthorizationCore` .
* Ont été déplacées vers *Microsoft.AspNetCore.Authorization.Policy.dll*.

Les applications qui utilisent à la fois *Microsoft.AspNetCore.Authorization.dll* et *Microsoft.AspNetCore.Authorization.Policy.dll* ne sont pas affectées.

Les applications qui n’utilisent pas *Microsoft.AspNetCore.Authorization.Policy.dll* doivent effectuer l’une des opérations suivantes :

* Ajoutez une référence à *Microsoft.AspNetCore.Authorization.Policy.dll*. Cette approche fonctionne pour la plupart des applications et est tout ce qui est nécessaire.
* Basculer vers using `AddAuthorizationCore`

Pour plus d’informations, consultez [modification avec rupture dans `AddAuthorization(o =>` ) dans un assembly différent #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="no-locidentity-ui"></a>Interface utilisateur du service Identity

Identity Mises à jour de l’interface utilisateur pour ASP.NET Core 3,0 :

* Ajoutez une référence de package à [Microsoft. AspNetCore. Identity Interface utilisateur](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Les applications qui n’utilisent pas de Razor pages doivent appeler `MapRazorPages` . Consultez les [ Razor pages](#razor-pages) de ce document.
* Bootstrap 4 est l’infrastructure d’interface utilisateur par défaut. Définissez une `IdentityUIFrameworkVersion` propriété de projet pour modifier la valeur par défaut. Pour plus d’informations, consultez [cette annonce GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Le SignalR client JavaScript est passé de `@aspnet/signalr` à `@microsoft/signalr` . Pour réagir à cette modification, modifiez les références dans *package.jssur* les fichiers, `require` les instructions et les `import` instructions ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Jssur est le protocole par défaut

`System.Text.Json` est maintenant le protocole de concentrateur par défaut utilisé par le client et le serveur.

Dans `Startup.ConfigureServices` , appelez `AddJsonProtocol` pour définir les options du sérialiseur.

**Serveurs**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Client :**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chathub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Basculer vers Newtonsoft.Jssur

Si vous utilisez [des fonctionnalités de Newtonsoft.Jsqui ne sont pas prises en charge dans System.Text.Jssur](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), vous pouvez revenir à `Newtonsoft.Json` . Consultez [utiliser Newtonsoft.Jssur dans un SignalR projet ASP.net Core 3,0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) plus haut dans cet article.

## <a name="redis-distributed-caches"></a>Caches distribués ReDim

Le package [Microsoft. extensions. Caching. redims](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) n’est pas disponible pour les applications ASP.net Core 3,0 ou versions ultérieures. Remplacez la référence de package par [Microsoft. extensions. Caching. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Pour plus d'informations, consultez <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Accepter la compilation au moment de l’exécution

Avant ASP.NET Core 3,0, la compilation du runtime des vues était une fonctionnalité implicite de l’infrastructure. La compilation Runtime complète la compilation des vues au moment de la génération. Il permet à l’infrastructure de compiler Razor des vues et des pages (fichiers *. cshtml* ) quand les fichiers sont modifiés, sans avoir à régénérer l’application entière. Cette fonctionnalité prend en charge le scénario d’apport d’une modification rapide dans l’IDE et d’actualisation du navigateur pour afficher les modifications.

Dans ASP.NET Core 3,0, la compilation du runtime est un scénario d’abonnement. La compilation au moment de la génération est le seul mécanisme pour la compilation de la vue qui est activée par défaut. Le runtime s’appuie sur Visual Studio ou [dotnet-Watch](xref:tutorials/dotnet-watch) dans Visual Studio code pour régénérer le projet lorsqu’il détecte des modifications apportées aux fichiers *. cshtml* . Dans Visual Studio, les modifications apportées aux fichiers *. cs*, *. cshtml* ou *. Razor* dans le projet en cours d’exécution (<kbd>CTRL + F5</kbd>), mais pas débogués (<kbd>F5</kbd>), déclenchent la recompilation du projet.

Pour activer la compilation au moment de l’exécution dans votre projet ASP.NET Core 3,0 :

1. Installez [Microsoft. AspNetCore. Mvc. Razor . ](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) Package NuGet RuntimeCompilation.
1. Mise à jour `Startup.ConfigureServices` pour appeler `AddRazorRuntimeCompilation` :

    Pour ASP.NET Core MVC, utilisez le code suivant :

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Pour ASP.NET Core Razor pages, utilisez le code suivant :
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
L’exemple dans https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation montre un exemple d’activation conditionnelle de la compilation au moment de l’exécution dans les environnements de développement.

Pour plus d’informations sur la Razor compilation de fichiers, consultez <xref:mvc/views/view-compilation> .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrer des bibliothèques via le multi-ciblage

Les bibliothèques doivent souvent prendre en charge plusieurs versions de ASP.NET Core. La plupart des bibliothèques qui ont été compilées avec des versions antérieures de ASP.NET Core doivent continuer à fonctionner sans problème. Les conditions suivantes nécessitent la compilation croisée de l’application :

* La bibliothèque s’appuie sur une fonctionnalité qui a une [modification avec rupture](#breaking-api-changes)binaire.
* La bibliothèque veut tirer parti des nouvelles fonctionnalités de ASP.NET Core 3,0. 

Par exemple :

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Utilisez `#ifdefs` pour activer des api ASP.NET Core 3,0 spécifiques :

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Pour plus d’informations sur l’utilisation d’API ASP.NET Core dans une bibliothèque de classes, consultez <xref:fundamentals/target-aspnetcore> .

## <a name="miscellaneous-changes"></a>Modifications diverses

Le système de validation dans .NET Core 3,0 et versions ultérieures traite les paramètres non Nullable ou les propriétés liées comme s’ils avaient un `[Required]` attribut. Pour plus d’informations, consultez [attribut [required]](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publier

Supprimez les dossiers *bin* et *obj* dans le répertoire du projet.

## <a name="testserver"></a>TestServer

Pour les applications qui utilisent <xref:Microsoft.AspNetCore.TestHost.TestServer> directement avec l' [hôte générique](xref:fundamentals/host/web-host), créez le `TestServer` sur un <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> dans <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Interruption des modifications d’API

Examiner les modifications avec rupture :

* [Liste complète des modifications avec rupture dans la version ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Interruption des modifications d’API dans anti-contrefaçon, cors, diagnostics, MVC et routage](https://github.com/aspnet/Announcements/issues/387). Cette liste comprend les modifications avec rupture pour les commutateurs de compatibilité.
* Pour obtenir un résumé des modifications avec rupture 2,2 à 3,0 sur .NET Core, ASP.NET Core et Entity Framework Core, consultez [modifications avec rupture pour la migration de la version 2,2 vers 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Routage de point de terminaison avec le paramètre Catch-All

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 sur Azure App Service

Le déploiement de .NET Core pour Azure App Service est terminé. .NET Core 3,0 est disponible dans tous les centres de Azure App Service.
