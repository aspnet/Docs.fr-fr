---
title: G√©rer les erreurs dans les Blazor applications ASP.net Core
author: guardrex
description: D√©couvrez comment ASP.NET Core Blazor comment Blazor g√®re les exceptions non g√©r√©es et comment d√©velopper des applications qui d√©tectent et g√®rent les erreurs.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 02/25/2021
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: blazor/fundamentals/handle-errors
zone_pivot_groups: blazor-hosting-models
ms.openlocfilehash: 96f4d7fcacf1f8eb03ffe83ba18b353e5588448e
ms.sourcegitcommit: a1db01b4d3bd8c57d7a9c94ce122a6db68002d66
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/04/2021
ms.locfileid: "102109704"
---
# <a name="handle-errors-in-aspnet-core-blazor-apps"></a>G√©rer les erreurs dans les Blazor applications ASP.net Core

Cet article explique comment Blazor g√®re les exceptions non g√©r√©es et comment d√©velopper des applications qui d√©tectent et g√®rent les erreurs.

::: zone pivot="webassembly"

## <a name="detailed-errors-during-development"></a>Erreurs d√©taill√©es pendant le d√©veloppement

Quand une Blazor application ne fonctionne pas correctement pendant le d√©veloppement, la r√©ception d‚Äôinformations d‚Äôerreur d√©taill√©es de l‚Äôapplication vous aide √† r√©soudre les probl√®mes et √† r√©soudre le probl√®me. Lorsqu‚Äôune erreur se produit, Blazor les applications affichent une barre jaune clair au bas de l‚Äô√©cran¬†:

* Pendant le d√©veloppement, la barre vous dirige vers la console du navigateur, o√π vous pouvez voir l‚Äôexception.
* En production, la barre avertit l‚Äôutilisateur qu‚Äôune erreur s‚Äôest produite et recommande l‚Äôactualisation du navigateur.

L‚Äôinterface utilisateur de cette exp√©rience de gestion des erreurs fait partie des Blazor mod√®les de projet.

Dans une Blazor WebAssembly application, personnalisez l‚Äôexp√©rience dans le `wwwroot/index.html` fichier¬†:

```html
<div id="blazor-error-ui">
    An unhandled error has occurred.
    <a href="" class="reload">Reload</a>
    <a class="dismiss">üóô</a>
</div>
```

L' `blazor-error-ui` √©l√©ment est normalement masqu√© en raison de la pr√©sence du `display: none` style de la `blazor-error-ui` classe CSS dans la feuille de style de l‚Äôapplication ( `wwwroot/css/app.css` ). Lorsqu‚Äôune erreur se produit, l‚Äôinfrastructure s‚Äôapplique `display: block` √† l‚Äô√©l√©ment.

## <a name="manage-unhandled-exceptions-in-developer-code"></a>G√©rer les exceptions non g√©r√©es dans le code du d√©veloppeur

Pour qu‚Äôune application continue apr√®s une erreur, l‚Äôapplication doit avoir une logique de gestion des erreurs. Les sections suivantes de cet article d√©crivent les sources potentielles d‚Äôexceptions non g√©r√©es.

En production, ne rendez pas les messages d‚Äôexception d‚Äôinfrastructure ou les traces de pile dans l‚Äôinterface utilisateur. Le rendu des messages d‚Äôexception ou des traces de pile peut¬†:

* Divulguer des informations sensibles aux utilisateurs finaux.
* Aidez un utilisateur malveillant √† d√©couvrir des faiblesses dans une application qui peuvent compromettre la s√©curit√© de l‚Äôapplication, du serveur ou du r√©seau.

## <a name="global-exception-handling"></a>Gestion globale des exceptions

[!INCLUDE[](~/blazor/includes/handle-errors/global-exception-handling.md)]

## <a name="log-errors-with-a-persistent-provider"></a>Consigner les erreurs avec un fournisseur persistant

Si une exception non g√©r√©e se produit, l‚Äôexception est consign√©e dans <xref:Microsoft.Extensions.Logging.ILogger> les instances configur√©es dans le conteneur de service. Par d√©faut, Blazor les applications se connectent √† la sortie de la console avec le fournisseur d‚Äôinformations de journalisation de la console. Envisagez de vous connecter √† un emplacement plus permanent sur le serveur en envoyant les informations d‚Äôerreur √† une API Web principale qui utilise un fournisseur de journalisation avec la gestion de la taille du journal et la rotation des journaux. L‚Äôapplication API Web principale peut √©galement utiliser un service de gestion des performances des applications (APM), tel que [Azure application Insights (Azure Monitor) &dagger; ](/azure/azure-monitor/app/app-insights-overview), pour enregistrer les informations d‚Äôerreur qu‚Äôelle re√ßoit des clients.

Vous devez choisir les incidents √† enregistrer et le niveau de gravit√© des incidents journalis√©s. Les utilisateurs hostiles peuvent √™tre en mesure de d√©clencher d√©lib√©r√©ment des erreurs. Par exemple, ne consignez pas un incident √† partir d‚Äôune erreur o√π un inconnu `ProductId` est fourni dans l‚ÄôURL d‚Äôun composant qui affiche les d√©tails du produit. Toutes les erreurs ne doivent pas √™tre trait√©es comme des incidents pour la journalisation.

Pour plus d‚Äôinformations, consultez les articles suivants¬†:

* <xref:blazor/fundamentals/logging>
* <xref:fundamentals/error-handling>&Dagger;
* <xref:web-api/index>

&dagger;Les fonctionnalit√©s [application Insights](/azure/azure-monitor/app/app-insights-overview) natives pour la prise en charge des Blazor WebAssembly applications et de la Blazor prise en charge native de [Google Analytics](https://analytics.google.com/analytics/web/) peuvent devenir disponibles dans les versions ult√©rieures de ces technologies. Pour plus d‚Äôinformations, consultez [prise en charge d‚Äôapplication Insights dans Blazor WASM client (Microsoft/ApplicationInsights-dotnet #2143)](https://github.com/microsoft/ApplicationInsights-dotnet/issues/2143) et [Web Analytics et diagnostics (y compris des liens vers les impl√©mentations de la Communaut√©) (dotnet/aspnetcore #5461)](https://github.com/dotnet/aspnetcore/issues/5461). En attendant, une application c√¥t√© client Blazor WebAssembly peut utiliser le kit de [d√©veloppement logiciel (SDK) JavaScript application Insights](/azure/azure-monitor/app/javascript) avec l' [interop√©rabilit√© de JS](xref:blazor/call-javascript-from-dotnet) pour consigner les erreurs directement sur application Insights √† partir d‚Äôune application c√¥t√© client.

&Dagger;S‚Äôapplique aux applications ASP.NET Core c√¥t√© serveur qui sont des applications principales d‚ÄôAPI Web pour les Blazor applications. Les applications c√¥t√© client interceptent et envoient des informations sur les erreurs √† une API Web, qui enregistre les informations d‚Äôerreur dans un fournisseur de journalisation persistant.

## <a name="places-where-errors-may-occur"></a>Emplacements o√π des erreurs peuvent se produire

Le code d‚Äôinfrastructure et d‚Äôapplication peut d√©clencher des exceptions non prises en charge dans l‚Äôun des emplacements suivants, d√©crits plus en d√©tail dans les sections suivantes de cet article¬†:

* [Instanciation du composant](#component-instantiation-webassembly)
* [M√©thodes de cycle de vie](#lifecycle-methods-webassembly)
* [Logique de rendu](#rendering-logic-webassembly)
* [Gestionnaires d‚Äô√©v√©nements](#event-handlers-webassembly)
* [Suppression de composants](#component-disposal-webassembly)
* [Interop√©rabilit√© JavaScript](#javascript-interop-webassembly)

<h3 id="component-instantiation-webassembly">Instanciation du composant</h3>

Lorsque Blazor cr√©e une instance d‚Äôun composant¬†:

* Le constructeur du composant est appel√©.
* Les constructeurs de tous les services d‚Äôinjection de code non Singleton fournis au constructeur du composant via la [`@inject`](xref:mvc/views/razor#inject) directive ou l' [ `[Inject]` attribut](xref:blazor/fundamentals/dependency-injection#request-a-service-in-a-component) sont appel√©s.

Une erreur dans un constructeur ex√©cut√© ou un accesseur Set pour une `[Inject]` propri√©t√© entra√Æne une exception non g√©r√©e et arr√™te l‚Äôinfrastructure de l‚Äôinstanciation du composant. Si la logique du constructeur peut lever des exceptions, l‚Äôapplication doit intercepter les exceptions √† l‚Äôaide d‚Äôune [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction avec la gestion des erreurs et la journalisation.

<h3 id="lifecycle-methods-webassembly">M√©thodes de cycle de vie</h3>

Pendant la dur√©e de vie d‚Äôun composant, Blazor appelle des [m√©thodes de cycle de vie](xref:blazor/components/lifecycle#lifecycle-methods). Pour les composants qui g√®rent les erreurs dans les m√©thodes de cycle de vie, ajoutez une logique de gestion des erreurs.

Dans l‚Äôexemple suivant, o√π <xref:Microsoft.AspNetCore.Components.ComponentBase.OnParametersSetAsync%2A> appelle une m√©thode pour obtenir un produit¬†:

* Une exception lev√©e dans la `ProductRepository.GetProductByIdAsync` m√©thode est g√©r√©e par une [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction.
* Lorsque le `catch` bloc est ex√©cut√©¬†:
  * `loadFailed` a la valeur `true` , qui est utilis√©e pour afficher un message d‚Äôerreur √† l‚Äôutilisateur.
  * L‚Äôerreur est consign√©e.

::: moniker range=">= aspnetcore-5.0"

[!code-razor[](~/blazor/common/samples/5.x/BlazorSample_WebAssembly/Pages/handle-errors/ProductDetails.razor?name=snippet&highlight=11,27-39)]

::: moniker-end

::: moniker range="< aspnetcore-5.0"

[!code-razor[](~/blazor/common/samples/3.x/BlazorSample_WebAssembly/Pages/handle-errors/ProductDetails.razor?name=snippet&highlight=11,27-39)]

::: moniker-end

<h3 id="rendering-logic-webassembly">Logique de rendu</h3>

Le balisage d√©claratif dans un Razor fichier de composant ( `.razor` ) est compil√© dans une m√©thode C# appel√©e <xref:Microsoft.AspNetCore.Components.ComponentBase.BuildRenderTree%2A> . Lorsqu‚Äôun composant affiche, <xref:Microsoft.AspNetCore.Components.ComponentBase.BuildRenderTree%2A> ex√©cute et g√©n√®re une structure de donn√©es d√©crivant les √©l√©ments, le texte et les composants enfants du composant rendu.

La logique de rendu peut lever une exception. Un exemple de ce sc√©nario se produit lorsque `@someObject.PropertyName` est √©valu√© `@someObject` , mais est `null` .

Pour emp√™cher une <xref:System.NullReferenceException> dans la logique de rendu, recherchez un `null` objet avant d‚Äôacc√©der √† ses membres. Dans l‚Äôexemple suivant, les `person.Address` Propri√©t√©s ne sont pas accessibles si `person.Address` est `null` :

::: moniker range=">= aspnetcore-5.0"

[!code-razor[](~/blazor/common/samples/5.x/BlazorSample_WebAssembly/Pages/handle-errors/PersonExample.razor?name=snippet&highlight=1)]

::: moniker-end

::: moniker range="< aspnetcore-5.0"

[!code-razor[](~/blazor/common/samples/3.x/BlazorSample_WebAssembly/Pages/handle-errors/PersonExample.razor?name=snippet&highlight=1)]

::: moniker-end

Le code pr√©c√©dent suppose que `person` ne l‚Äôest pas `null` . Souvent, la structure du code garantit l‚Äôexistence d‚Äôun objet au moment du rendu du composant. Dans ce cas, il n‚Äôest pas n√©cessaire de rechercher `null` dans la logique de rendu. Dans l‚Äôexemple pr√©c√©dent, `person` peut √™tre garanti qu‚Äôil existe, car `person` est cr√©√© lors de l‚Äôinstanciation du composant, comme le montre l‚Äôexemple suivant¬†:

```razor
@code {
    private Person person = new Person();

    ...
}
```

<h3 id="event-handlers-webassembly">Gestionnaires d‚Äô√©v√©nements</h3>

Le code c√¥t√© client d√©clenche des appels de code C# lors de la cr√©ation de gestionnaires d‚Äô√©v√©nements √† l‚Äôaide de¬†:

* `@onclick`
* `@onchange`
* Autres `@on...` attributs
* `@bind`

Le code du gestionnaire d‚Äô√©v√©nements peut lever une exception non g√©r√©e dans ces sc√©narios.

Si l‚Äôapplication appelle du code qui pourrait √©chouer pour des raisons externes, interceptez les exceptions √† l‚Äôaide d‚Äôune [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction avec gestion des erreurs et journalisation.

Si le code utilisateur n‚Äôintercepte pas et ne g√®re pas l‚Äôexception, le Framework journalise l‚Äôexception.

<h3 id="component-disposal-webassembly">Suppression de composants</h3>

Un composant peut √™tre supprim√© de l‚Äôinterface utilisateur, par exemple, parce que l‚Äôutilisateur a acc√©d√© √† une autre page. Quand un composant qui impl√©mente <xref:System.IDisposable?displayProperty=fullName> est supprim√© de l‚Äôinterface utilisateur, le Framework appelle la m√©thode du composant <xref:System.IDisposable.Dispose%2A> .

Si la logique de suppression peut lever des exceptions, l‚Äôapplication doit intercepter les exceptions √† l‚Äôaide d‚Äôune [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction avec la gestion des erreurs et la journalisation.

Pour plus d‚Äôinformations sur la suppression de composants, consultez <xref:blazor/components/lifecycle#component-disposal-with-idisposable> .

<h3 id="javascript-interop-webassembly">Interop√©rabilit√© JavaScript</h3>

<xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A?displayProperty=nameWithType> permet au code .NET d‚Äôeffectuer des appels asynchrones au runtime JavaScript dans le navigateur de l‚Äôutilisateur.

Les conditions suivantes s‚Äôappliquent √† la gestion des erreurs avec <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> :

* Si un appel √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> √©choue de fa√ßon synchrone, une exception .net se produit. Un appel √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> peut √©chouer, par exemple, car les arguments fournis ne peuvent pas √™tre s√©rialis√©s. Le code du d√©veloppeur doit intercepter l‚Äôexception.
* Si un appel √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> √©choue de mani√®re asynchrone, le .NET <xref:System.Threading.Tasks.Task> √©choue. Un appel √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> peut √©chouer, par exemple, parce que le code c√¥t√© JavaScript l√®ve une exception ou retourne un `Promise` qui s‚Äôest termin√© comme `rejected` . Le code du d√©veloppeur doit intercepter l‚Äôexception. Si vous utilisez l' [`await`](/dotnet/csharp/language-reference/keywords/await) op√©rateur, encapsulez l‚Äôappel de m√©thode dans une [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction avec la gestion des erreurs et la journalisation.
* Par d√©faut, les appels √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> doivent se terminer dans un laps de temps donn√©, sinon l‚Äôappel expire. Le d√©lai d‚Äôexpiration par d√©faut est d‚Äôune minute. Le d√©lai d‚Äôattente prot√®ge le code contre toute perte de connectivit√© r√©seau ou de code JavaScript qui ne renvoie jamais de message d‚Äôach√®vement. Si l‚Äôappel expire, le r√©sultant <xref:System.Threading.Tasks> √©choue avec un <xref:System.OperationCanceledException> . Interceptez et traitez l‚Äôexception avec la journalisation.

De m√™me, le code JavaScript peut initier des appels √† des m√©thodes .NET indiqu√©es par l' [ `[JSInvokable]` attribut](xref:blazor/call-dotnet-from-javascript). Si ces m√©thodes .NET l√®vent une exception non g√©r√©e, le c√¥t√© JavaScript `Promise` est rejet√©.

Vous avez la possibilit√© d‚Äôutiliser le code de gestion des erreurs c√¥t√© .NET ou JavaScript de l‚Äôappel de m√©thode.

Pour plus d‚Äôinformations, consultez les articles suivants¬†:

* <xref:blazor/call-javascript-from-dotnet>
* <xref:blazor/call-dotnet-from-javascript>

## <a name="advanced-scenarios"></a>Sc√©narios avanc√©s

### <a name="recursive-rendering"></a>Rendu r√©cursif

Les composants peuvent √™tre imbriqu√©s de mani√®re r√©cursive. Cela est utile pour repr√©senter des structures de donn√©es r√©cursives. Par exemple, un `TreeNode` composant peut restituer plus de `TreeNode` composants pour chacun des enfants du n≈ìud.

Lors du rendu de mani√®re r√©cursive, √©vitez les mod√®les de codage qui se traduisent par une r√©currence infinie¬†:

* Ne rendez pas de mani√®re r√©cursive une structure de donn√©es qui contient un cycle. Par exemple, n‚Äôaffichez pas un n≈ìud d‚Äôarbre dont les enfants s‚Äôy trouvent.
* Ne cr√©ez pas une cha√Æne de dispositions qui contiennent un cycle. Par exemple, ne cr√©ez pas une disposition dont la disposition est elle-m√™me.
* N‚Äôautorisez pas un utilisateur final √† enfreindre les invariants de r√©currence (r√®gles) par le biais d‚Äôune entr√©e de donn√©es malveillante ou d‚Äôappels Interop JavaScript.

Boucles infinies pendant le rendu¬†:

* Fait en sorte que le processus de rendu continue de fa√ßon permanente.
* √âquivaut √† cr√©er une boucle non termin√©e.

Dans ces sc√©narios, le thread tente g√©n√©ralement d‚Äôeffectuer les op√©rations suivantes¬†:

* Consommez le plus de temps processeur autoris√© par le syst√®me d‚Äôexploitation, ind√©finiment.
* Consommez une quantit√© illimit√©e de m√©moire client. La consommation de m√©moire illimit√©e est √©quivalente au sc√©nario dans lequel une boucle non termin√©e ajoute des entr√©es √† une collection √† chaque it√©ration.

Pour √©viter les mod√®les de r√©currence infinis, assurez-vous que le code de rendu r√©cursif contient des conditions d‚Äôarr√™t appropri√©es.

### <a name="custom-render-tree-logic"></a>Logique d‚Äôarborescence de rendu personnalis√©

La plupart des Blazor composants sont impl√©ment√©s en tant que Razor fichiers de composants ( `.razor` ) et sont compil√©s par l‚Äôinfrastructure pour produire une logique qui op√®re sur un <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder> pour afficher leur sortie. Toutefois, un d√©veloppeur peut impl√©menter la <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder> logique manuellement √† l‚Äôaide du code C# proc√©dural. Pour plus d‚Äôinformations, consultez <xref:blazor/advanced-scenarios#manual-rendertreebuilder-logic>.

> [!WARNING]
> L‚Äôutilisation de la logique du g√©n√©rateur d‚Äôarborescence de rendu manuel est consid√©r√©e comme un sc√©nario avanc√© et risqu√©, non recommand√© pour le d√©veloppement de composants g√©n√©raux.

Si le <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder> code est √©crit, le d√©veloppeur doit garantir l‚Äôexactitude du code. Par exemple, le d√©veloppeur doit s‚Äôassurer que¬†:

* Les appels √† <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.OpenElement%2A> et <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.CloseElement%2A> sont correctement √©quilibr√©s.
* Les attributs sont ajout√©s uniquement aux emplacements appropri√©s.

Une logique de g√©n√©rateur d‚Äôarborescence de rendu manuel incorrecte peut entra√Æner un comportement arbitraire ind√©fini, y compris des incidents, des blocages d‚Äôapplication et des failles de s√©curit√©.

Consid√©rez la logique du g√©n√©rateur d‚Äôarborescence de rendu manuel sur le m√™me niveau de complexit√© et avec le m√™me niveau de *danger* que l‚Äô√©criture de code assembleur ou d‚Äôinstructions [MSIL (Microsoft Intermediate Language)](/dotnet/standard/managed-code) manuellement.

## <a name="additional-resources"></a>Ressources suppl√©mentaires

* <xref:blazor/fundamentals/logging>
* <xref:fundamentals/error-handling>&dagger;
* <xref:web-api/index>

&dagger;S‚Äôapplique au serveur principal ASP.NET Core applications API Web que Blazor WebAssembly les applications c√¥t√© client utilisent pour la journalisation.

::: zone-end

::: zone pivot="server"

## <a name="detailed-errors-during-development"></a>Erreurs d√©taill√©es pendant le d√©veloppement

Quand une Blazor application ne fonctionne pas correctement pendant le d√©veloppement, la r√©ception d‚Äôinformations d‚Äôerreur d√©taill√©es de l‚Äôapplication vous aide √† r√©soudre les probl√®mes et √† r√©soudre le probl√®me. Lorsqu‚Äôune erreur se produit, Blazor les applications affichent une barre jaune clair au bas de l‚Äô√©cran¬†:

* Pendant le d√©veloppement, la barre vous dirige vers la console du navigateur, o√π vous pouvez voir l‚Äôexception.
* En production, la barre avertit l‚Äôutilisateur qu‚Äôune erreur s‚Äôest produite et recommande l‚Äôactualisation du navigateur.

L‚Äôinterface utilisateur de cette exp√©rience de gestion des erreurs fait partie des Blazor mod√®les de projet.

Dans une Blazor Server application, personnalisez l‚Äôexp√©rience dans le `Pages/_Host.cshtml` fichier¬†:

```cshtml
<div id="blazor-error-ui">
    <environment include="Staging,Production">
        An error has occurred. This application may no longer respond until reloaded.
    </environment>
    <environment include="Development">
        An unhandled exception has occurred. See browser dev tools for details.
    </environment>
    <a href="" class="reload">Reload</a>
    <a class="dismiss">üóô</a>
</div>
```

L' `blazor-error-ui` √©l√©ment est normalement masqu√© en raison de la pr√©sence du `display: none` style de la `blazor-error-ui` classe CSS dans la feuille de style du site ( `wwwroot/css/site.css` ). Lorsqu‚Äôune erreur se produit, l‚Äôinfrastructure s‚Äôapplique `display: block` √† l‚Äô√©l√©ment.

## <a name="blazor-server-detailed-circuit-errors"></a>Blazor Server Erreurs de circuit d√©taill√©es

Les erreurs c√¥t√© client n‚Äôincluent pas la pile des appels et ne fournissent pas de d√©tails sur la cause de l‚Äôerreur, mais les journaux du serveur contiennent ces informations. √Ä des fins de d√©veloppement, des informations sur les erreurs de circuit sensible peuvent √™tre mises √† la disposition du client en activant des erreurs d√©taill√©es.

D√©finissez <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.DetailedErrors?displayProperty=nameWithType> sur `true`. Pour plus d'informations et pour obtenir un exemple, consultez <xref:blazor/fundamentals/signalr#circuit-handler-options>.

Une alternative √† la d√©finition de <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.DetailedErrors?displayProperty=nameWithType> est de d√©finir la `DetailedErrors` cl√© de configuration sur `true` dans le fichier de param√®tres de l‚Äôenvironnement de d√©veloppement de l‚Äôapplication ( `appsettings.Development.json` ).  En outre, d√©finissez la [ SignalR journalisation c√¥t√© serveur](xref:signalr/diagnostics#server-side-logging) ( `Microsoft.AspNetCore.SignalR` ) √† [D√©boguer](xref:Microsoft.Extensions.Logging.LogLevel) ou √† [suivre](xref:Microsoft.Extensions.Logging.LogLevel) pour la SignalR journalisation d√©taill√©e.

`appsettings.Development.json`:

```json
{
  "DetailedErrors": true,
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information",
      "Microsoft.AspNetCore.SignalR": "Debug"
    }
  }
}
```

La <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.DetailedErrors> cl√© de configuration peut √©galement √™tre d√©finie pour `true` utiliser la `ASPNETCORE_DETAILEDERRORS` variable d‚Äôenvironnement avec la valeur sur les serveurs d‚Äôenvironnement de `true` d√©veloppement/interm√©diaire ou sur votre syst√®me local.

> [!WARNING]
> √âvitez toujours d‚Äôexposer les informations d‚Äôerreur aux clients sur Internet, ce qui constitue un risque pour la s√©curit√©.

## <a name="how-a-blazor-server-app-reacts-to-unhandled-exceptions"></a>Comment une Blazor Server application r√©agit aux exceptions non g√©r√©es

Blazor Server est une infrastructure avec √©tat. Tandis que les utilisateurs interagissent avec une application, ils maintiennent une connexion au serveur appel√© ¬´ *circuit*¬ª. Le circuit contient des instances de composant actives, ainsi que de nombreux autres aspects de l‚Äô√âtat, tels que¬†:

* Sortie du rendu le plus r√©cent des composants.
* Ensemble actuel de d√©l√©gu√©s de gestion d‚Äô√©v√©nements qui peuvent √™tre d√©clench√©s par les √©v√©nements c√¥t√© client.

Si un utilisateur ouvre l‚Äôapplication dans plusieurs onglets de navigateur, il cr√©e plusieurs circuits ind√©pendants.

Blazor traite la plupart des exceptions non g√©r√©es comme √©tant irr√©cup√©rables par le circuit dans lequel elles se produisent. Si un circuit est arr√™t√© en raison d‚Äôune exception non g√©r√©e, l‚Äôutilisateur ne peut continuer √† interagir avec l‚Äôapplication qu‚Äôen rechargeant la page pour cr√©er un nouveau circuit. Les circuits en dehors de celui qui est termin√©, qui sont des circuits pour d‚Äôautres utilisateurs ou d‚Äôautres onglets de navigateur, ne sont pas affect√©s. Ce sc√©nario est similaire √† une application de bureau qui se bloque. L‚Äôapplication bloqu√©e doit √™tre red√©marr√©e, mais les autres applications ne sont pas affect√©es.

Le Framework met fin √† un circuit lorsqu‚Äôune exception non g√©r√©e se produit pour les raisons suivantes¬†:

* Une exception non g√©r√©e rend souvent le circuit dans un √âtat ind√©fini.
* L‚Äôop√©ration normale de l‚Äôapplication ne peut pas √™tre garantie apr√®s une exception non g√©r√©e.
* Des failles de s√©curit√© peuvent appara√Ætre dans l‚Äôapplication si le circuit continue dans un √âtat ind√©fini.

## <a name="manage-unhandled-exceptions-in-developer-code"></a>G√©rer les exceptions non g√©r√©es dans le code du d√©veloppeur

Pour qu‚Äôune application continue apr√®s une erreur, l‚Äôapplication doit avoir une logique de gestion des erreurs. Les sections suivantes de cet article d√©crivent les sources potentielles d‚Äôexceptions non g√©r√©es.

En production, ne rendez pas les messages d‚Äôexception d‚Äôinfrastructure ou les traces de pile dans l‚Äôinterface utilisateur. Le rendu des messages d‚Äôexception ou des traces de pile peut¬†:

* Divulguer des informations sensibles aux utilisateurs finaux.
* Aidez un utilisateur malveillant √† d√©couvrir des faiblesses dans une application qui peuvent compromettre la s√©curit√© de l‚Äôapplication, du serveur ou du r√©seau.

## <a name="global-exception-handling"></a>Gestion globale des exceptions

[!INCLUDE[](~/blazor/includes/handle-errors/global-exception-handling.md)]

√âtant donn√© que les approches de cette section g√®rent les erreurs avec une [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction, la SignalR connexion entre le client et le serveur n‚Äôest pas interrompue lorsqu‚Äôune erreur se produit et que le circuit reste actif. Toute exception non g√©r√©e est irr√©m√©diable pour un circuit. Pour plus d‚Äôinformations, consultez la section pr√©c√©dente sur [la mani√®re dont une Blazor Server application r√©agit aux exceptions non g√©r√©es](#how-a-blazor-server-app-reacts-to-unhandled-exceptions).

## <a name="log-errors-with-a-persistent-provider"></a>Consigner les erreurs avec un fournisseur persistant

Si une exception non g√©r√©e se produit, l‚Äôexception est consign√©e dans <xref:Microsoft.Extensions.Logging.ILogger> les instances configur√©es dans le conteneur de service. Par d√©faut, Blazor les applications se connectent √† la sortie de la console avec le fournisseur d‚Äôinformations de journalisation de la console. Envisagez de vous connecter √† un emplacement plus permanent sur le serveur avec un fournisseur qui g√®re la taille du journal et la rotation des journaux. L‚Äôapplication peut √©galement utiliser un service de gestion des performances des applications (APM), tel que [Azure application Insights (Azure Monitor)](/azure/azure-monitor/app/app-insights-overview).

Pendant le d√©veloppement, une Blazor Server application envoie g√©n√©ralement les d√©tails complets des exceptions √† la console du navigateur pour faciliter le d√©bogage. En production, les erreurs d√©taill√©es ne sont pas envoy√©es aux clients, mais les d√©tails complets d‚Äôune exception sont enregistr√©s sur le serveur.

Vous devez choisir les incidents √† enregistrer et le niveau de gravit√© des incidents journalis√©s. Les utilisateurs hostiles peuvent √™tre en mesure de d√©clencher d√©lib√©r√©ment des erreurs. Par exemple, ne consignez pas un incident √† partir d‚Äôune erreur o√π un inconnu `ProductId` est fourni dans l‚ÄôURL d‚Äôun composant qui affiche les d√©tails du produit. Toutes les erreurs ne doivent pas √™tre trait√©es comme des incidents pour la journalisation.

Pour plus d‚Äôinformations, consultez les articles suivants¬†:

* <xref:blazor/fundamentals/logging>
* <xref:fundamentals/error-handling>&dagger;

&dagger;S‚Äôapplique aux applications ASP.NET Core c√¥t√© serveur qui sont des applications principales d‚ÄôAPI Web pour les Blazor applications.

## <a name="places-where-errors-may-occur"></a>Emplacements o√π des erreurs peuvent se produire

Le code d‚Äôinfrastructure et d‚Äôapplication peut d√©clencher des exceptions non prises en charge dans l‚Äôun des emplacements suivants, d√©crits plus en d√©tail dans les sections suivantes de cet article¬†:

* [Instanciation du composant](#component-instantiation-server)
* [M√©thodes de cycle de vie](#lifecycle-methods-server)
* [Logique de rendu](#rendering-logic-server)
* [Gestionnaires d‚Äô√©v√©nements](#event-handlers-server)
* [Suppression de composants](#component-disposal-server)
* [Interop√©rabilit√© JavaScript](#javascript-interop-server)
* [Blazor Server rerendu](#blazor-server-prerendering-server)

<h3 id="component-instantiation-server">Instanciation du composant</h3>

Lorsque Blazor cr√©e une instance d‚Äôun composant¬†:

* Le constructeur du composant est appel√©.
* Les constructeurs de tous les services d‚Äôinjection de code non Singleton fournis au constructeur du composant via la [`@inject`](xref:mvc/views/razor#inject) directive ou l' [ `[Inject]` attribut](xref:blazor/fundamentals/dependency-injection#request-a-service-in-a-component) sont appel√©s.

Un Blazor Server circuit √©choue quand un constructeur ex√©cut√© ou une m√©thode setter pour une `[Inject]` propri√©t√© l√®ve une exception non g√©r√©e. L‚Äôexception est irr√©cup√©rable, car l‚Äôinfrastructure ne peut pas instancier le composant. Si la logique du constructeur peut lever des exceptions, l‚Äôapplication doit intercepter les exceptions √† l‚Äôaide d‚Äôune [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction avec la gestion des erreurs et la journalisation.

<h3 id="lifecycle-methods-server">M√©thodes de cycle de vie</h3>

Pendant la dur√©e de vie d‚Äôun composant, Blazor appelle des [m√©thodes de cycle de vie](xref:blazor/components/lifecycle#lifecycle-methods). Si une m√©thode de cycle de vie l√®ve une exception, de mani√®re synchrone ou asynchrone, l‚Äôexception est irr√©cup√©rable pour un Blazor Server circuit. Pour les composants qui g√®rent les erreurs dans les m√©thodes de cycle de vie, ajoutez une logique de gestion des erreurs.

Dans l‚Äôexemple suivant, o√π <xref:Microsoft.AspNetCore.Components.ComponentBase.OnParametersSetAsync%2A> appelle une m√©thode pour obtenir un produit¬†:

* Une exception lev√©e dans la `ProductRepository.GetProductByIdAsync` m√©thode est g√©r√©e par une [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction.
* Lorsque le `catch` bloc est ex√©cut√©¬†:
  * `loadFailed` a la valeur `true` , qui est utilis√©e pour afficher un message d‚Äôerreur √† l‚Äôutilisateur.
  * L‚Äôerreur est consign√©e.

::: moniker range=">= aspnetcore-5.0"

[!code-razor[](~/blazor/common/samples/5.x/BlazorSample_Server/Pages/handle-errors/ProductDetails.razor?name=snippet&highlight=11,27-39)]

::: moniker-end

::: moniker range="< aspnetcore-5.0"

[!code-razor[](~/blazor/common/samples/3.x/BlazorSample_Server/Pages/handle-errors/ProductDetails.razor?name=snippet&highlight=11,27-39)]

::: moniker-end

<h3 id="rendering-logic-server">Logique de rendu</h3>

Le balisage d√©claratif dans un Razor fichier de composant ( `.razor` ) est compil√© dans une m√©thode C# appel√©e <xref:Microsoft.AspNetCore.Components.ComponentBase.BuildRenderTree%2A> . Lorsqu‚Äôun composant affiche, <xref:Microsoft.AspNetCore.Components.ComponentBase.BuildRenderTree%2A> ex√©cute et g√©n√®re une structure de donn√©es d√©crivant les √©l√©ments, le texte et les composants enfants du composant rendu.

La logique de rendu peut lever une exception. Un exemple de ce sc√©nario se produit lorsque `@someObject.PropertyName` est √©valu√© `@someObject` , mais est `null` . Une exception non g√©r√©e lev√©e par la logique de rendu est irr√©cup√©rable pour un Blazor Server circuit.

Pour emp√™cher une <xref:System.NullReferenceException> dans la logique de rendu, recherchez un `null` objet avant d‚Äôacc√©der √† ses membres. Dans l‚Äôexemple suivant, les `person.Address` Propri√©t√©s ne sont pas accessibles si `person.Address` est `null` :

::: moniker range=">= aspnetcore-5.0"

[!code-razor[](~/blazor/common/samples/5.x/BlazorSample_Server/Pages/handle-errors/PersonExample.razor?name=snippet&highlight=1)]

::: moniker-end

::: moniker range="< aspnetcore-5.0"

[!code-razor[](~/blazor/common/samples/3.x/BlazorSample_Server/Pages/handle-errors/PersonExample.razor?name=snippet&highlight=1)]

::: moniker-end

Le code pr√©c√©dent suppose que `person` ne l‚Äôest pas `null` . Souvent, la structure du code garantit l‚Äôexistence d‚Äôun objet au moment du rendu du composant. Dans ce cas, il n‚Äôest pas n√©cessaire de rechercher `null` dans la logique de rendu. Dans l‚Äôexemple pr√©c√©dent, `person` peut √™tre garanti qu‚Äôil existe, car `person` est cr√©√© lors de l‚Äôinstanciation du composant, comme le montre l‚Äôexemple suivant¬†:

```razor
@code {
    private Person person = new Person();

    ...
}
```

<h3 id="event-handlers-server">Gestionnaires d‚Äô√©v√©nements</h3>

Le code c√¥t√© client d√©clenche des appels de code C# lors de la cr√©ation de gestionnaires d‚Äô√©v√©nements √† l‚Äôaide de¬†:

* `@onclick`
* `@onchange`
* Autres `@on...` attributs
* `@bind`

Le code du gestionnaire d‚Äô√©v√©nements peut lever une exception non g√©r√©e dans ces sc√©narios.

Si un gestionnaire d‚Äô√©v√©nements l√®ve une exception non g√©r√©e (par exemple, une requ√™te de base de donn√©es √©choue), l‚Äôexception est irr√©cup√©rable pour un Blazor Server circuit. Si l‚Äôapplication appelle du code qui pourrait √©chouer pour des raisons externes, interceptez les exceptions √† l‚Äôaide d‚Äôune [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction avec gestion des erreurs et journalisation.

Si le code utilisateur n‚Äôintercepte pas et ne g√®re pas l‚Äôexception, le Framework journalise l‚Äôexception et met fin au circuit.

<h3 id="component-disposal-server">Suppression de composants</h3>

Un composant peut √™tre supprim√© de l‚Äôinterface utilisateur, par exemple, parce que l‚Äôutilisateur a acc√©d√© √† une autre page. Quand un composant qui impl√©mente <xref:System.IDisposable?displayProperty=fullName> est supprim√© de l‚Äôinterface utilisateur, le Framework appelle la m√©thode du composant <xref:System.IDisposable.Dispose%2A> .

Si la m√©thode du composant `Dispose` l√®ve une exception non g√©r√©e, l‚Äôexception est irr√©cup√©rable pour un Blazor Server circuit. Si la logique de suppression peut lever des exceptions, l‚Äôapplication doit intercepter les exceptions √† l‚Äôaide d‚Äôune [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction avec la gestion des erreurs et la journalisation.

Pour plus d‚Äôinformations sur la suppression de composants, consultez <xref:blazor/components/lifecycle#component-disposal-with-idisposable> .

<h3 id="javascript-interop-server">Interop√©rabilit√© JavaScript</h3>

<xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A?displayProperty=nameWithType> permet au code .NET d‚Äôeffectuer des appels asynchrones au runtime JavaScript dans le navigateur de l‚Äôutilisateur.

Les conditions suivantes s‚Äôappliquent √† la gestion des erreurs avec <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> :

* Si un appel √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> √©choue de fa√ßon synchrone, une exception .net se produit. Un appel √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> peut √©chouer, par exemple, car les arguments fournis ne peuvent pas √™tre s√©rialis√©s. Le code du d√©veloppeur doit intercepter l‚Äôexception. Si le code d‚Äôapplication dans une m√©thode de gestionnaire d‚Äô√©v√©nements ou de cycle de vie de composant ne g√®re pas une exception, l‚Äôexception r√©sultante est irr√©cup√©rable pour un Blazor Server circuit.
* Si un appel √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> √©choue de mani√®re asynchrone, le .NET <xref:System.Threading.Tasks.Task> √©choue. Un appel √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> peut √©chouer, par exemple, parce que le code c√¥t√© JavaScript l√®ve une exception ou retourne un `Promise` qui s‚Äôest termin√© comme `rejected` . Le code du d√©veloppeur doit intercepter l‚Äôexception. Si vous utilisez l' [`await`](/dotnet/csharp/language-reference/keywords/await) op√©rateur, encapsulez l‚Äôappel de m√©thode dans une [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction avec la gestion des erreurs et la journalisation. Dans le cas contraire, le code d√©faillant entra√Æne une exception non g√©r√©e qui est irr√©cup√©rable pour un Blazor Server circuit.
* Par d√©faut, les appels √† <xref:Microsoft.JSInterop.IJSRuntime.InvokeAsync%2A> doivent se terminer dans un laps de temps donn√©, sinon l‚Äôappel expire. Le d√©lai d‚Äôexpiration par d√©faut est d‚Äôune minute. Le d√©lai d‚Äôattente prot√®ge le code contre toute perte de connectivit√© r√©seau ou de code JavaScript qui ne renvoie jamais de message d‚Äôach√®vement. Si l‚Äôappel expire, le r√©sultant <xref:System.Threading.Tasks> √©choue avec un <xref:System.OperationCanceledException> . Interceptez et traitez l‚Äôexception avec la journalisation.

De m√™me, le code JavaScript peut initier des appels √† des m√©thodes .NET indiqu√©es par l' [ `[JSInvokable]` attribut](xref:blazor/call-dotnet-from-javascript). Si ces m√©thodes .NET l√®vent une exception non g√©r√©e¬†:

* L‚Äôexception n‚Äôest pas trait√©e comme √©tant irr√©cup√©rable pour un Blazor Server circuit.
* Le c√¥t√© JavaScript `Promise` est rejet√©.

Vous avez la possibilit√© d‚Äôutiliser le code de gestion des erreurs c√¥t√© .NET ou JavaScript de l‚Äôappel de m√©thode.

Pour plus d‚Äôinformations, consultez les articles suivants¬†:

* <xref:blazor/call-javascript-from-dotnet>
* <xref:blazor/call-dotnet-from-javascript>

<h3 id="blazor-server-prerendering-server">Blazor Server pr√©affichant</h3>

Blazor les composants peuvent √™tre pr√©rendus √† l‚Äôaide du [tag Helper du composant](xref:mvc/views/tag-helpers/builtin-th/component-tag-helper) , afin que le balisage HTML rendu soit renvoy√© dans le cadre de la requ√™te http initiale de l‚Äôutilisateur. Cela fonctionne de la fa√ßon suivante¬†:

* Cr√©ation d‚Äôun nouveau circuit pour tous les composants pr√©rendus qui font partie de la m√™me page.
* G√©n√©ration du code HTML initial.
* Traitement du circuit comme `disconnected` jusqu‚Äô√† ce que le navigateur de l‚Äôutilisateur √©tablisse une SignalR connexion avec le m√™me serveur. Lorsque la connexion est √©tablie, l‚Äôinteractivit√© sur le circuit est reprise et le balisage HTML des composants est mis √† jour.

Si un composant l√®ve une exception non g√©r√©e pendant le pr√©rendu, par exemple, pendant une m√©thode de cycle de vie ou dans une logique de rendu¬†:

* L‚Äôexception est irr√©cup√©rable pour le circuit.
* L‚Äôexception est lev√©e dans la pile des appels √† partir du <xref:Microsoft.AspNetCore.Mvc.TagHelpers.ComponentTagHelper> tag Helper. Par cons√©quent, la requ√™te HTTP enti√®re √©choue, sauf si l‚Äôexception est explicitement intercept√©e par le code du d√©veloppeur.

Dans des circonstances normales, lorsque le pr√©rendu √©choue, la cr√©ation et le rendu du composant n‚Äôont pas de sens, car un composant de travail ne peut pas √™tre rendu.

Pour tol√©rer les erreurs qui peuvent se produire pendant le pr√©rendu, la logique de gestion des erreurs doit √™tre plac√©e √† l‚Äôint√©rieur d‚Äôun composant qui peut lever des exceptions. Utilisez des [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instructions avec la gestion des erreurs et la journalisation. Au lieu d‚Äôencapsuler le <xref:Microsoft.AspNetCore.Mvc.TagHelpers.ComponentTagHelper> tag Helper dans une [`try-catch`](/dotnet/csharp/language-reference/keywords/try-catch) instruction, placez la logique de gestion des erreurs dans le composant rendu par le <xref:Microsoft.AspNetCore.Mvc.TagHelpers.ComponentTagHelper> tag Helper.

## <a name="advanced-scenarios"></a>Sc√©narios avanc√©s

### <a name="recursive-rendering"></a>Rendu r√©cursif

Les composants peuvent √™tre imbriqu√©s de mani√®re r√©cursive. Cela est utile pour repr√©senter des structures de donn√©es r√©cursives. Par exemple, un `TreeNode` composant peut restituer plus de `TreeNode` composants pour chacun des enfants du n≈ìud.

Lors du rendu de mani√®re r√©cursive, √©vitez les mod√®les de codage qui se traduisent par une r√©currence infinie¬†:

* Ne rendez pas de mani√®re r√©cursive une structure de donn√©es qui contient un cycle. Par exemple, n‚Äôaffichez pas un n≈ìud d‚Äôarbre dont les enfants s‚Äôy trouvent.
* Ne cr√©ez pas une cha√Æne de dispositions qui contiennent un cycle. Par exemple, ne cr√©ez pas une disposition dont la disposition est elle-m√™me.
* N‚Äôautorisez pas un utilisateur final √† enfreindre les invariants de r√©currence (r√®gles) par le biais d‚Äôune entr√©e de donn√©es malveillante ou d‚Äôappels Interop JavaScript.

Boucles infinies pendant le rendu¬†:

* Fait en sorte que le processus de rendu continue de fa√ßon permanente.
* √âquivaut √† cr√©er une boucle non termin√©e.

Dans ces sc√©narios, un Blazor Server circuit affect√© √©choue et le thread tente g√©n√©ralement d‚Äôeffectuer les op√©rations suivantes¬†:

* Consommez le plus de temps processeur autoris√© par le syst√®me d‚Äôexploitation, ind√©finiment.
* Consommez une quantit√© illimit√©e de m√©moire serveur. La consommation de m√©moire illimit√©e est √©quivalente au sc√©nario dans lequel une boucle non termin√©e ajoute des entr√©es √† une collection √† chaque it√©ration.

Pour √©viter les mod√®les de r√©currence infinis, assurez-vous que le code de rendu r√©cursif contient des conditions d‚Äôarr√™t appropri√©es.

### <a name="custom-render-tree-logic"></a>Logique d‚Äôarborescence de rendu personnalis√©

La plupart des Blazor composants sont impl√©ment√©s en tant que Razor fichiers de composants ( `.razor` ) et sont compil√©s par l‚Äôinfrastructure pour produire une logique qui op√®re sur un <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder> pour afficher leur sortie. Toutefois, un d√©veloppeur peut impl√©menter la <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder> logique manuellement √† l‚Äôaide du code C# proc√©dural. Pour plus d‚Äôinformations, consultez <xref:blazor/advanced-scenarios#manual-rendertreebuilder-logic>.

> [!WARNING]
> L‚Äôutilisation de la logique du g√©n√©rateur d‚Äôarborescence de rendu manuel est consid√©r√©e comme un sc√©nario avanc√© et risqu√©, non recommand√© pour le d√©veloppement de composants g√©n√©raux.

Si le <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder> code est √©crit, le d√©veloppeur doit garantir l‚Äôexactitude du code. Par exemple, le d√©veloppeur doit s‚Äôassurer que¬†:

* Les appels √† <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.OpenElement%2A> et <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.CloseElement%2A> sont correctement √©quilibr√©s.
* Les attributs sont ajout√©s uniquement aux emplacements appropri√©s.

Une logique incorrecte du g√©n√©rateur d‚Äôarborescence de rendu manuel peut entra√Æner un comportement arbitraire non d√©fini, y compris des pannes, des blocages du serveur et des failles de s√©curit√©.

Consid√©rez la logique du g√©n√©rateur d‚Äôarborescence de rendu manuel sur le m√™me niveau de complexit√© et avec le m√™me niveau de *danger* que l‚Äô√©criture de code assembleur ou d‚Äôinstructions [MSIL (Microsoft Intermediate Language)](/dotnet/standard/managed-code) manuellement.

## <a name="additional-resources"></a>Ressources suppl√©mentaires

* <xref:blazor/fundamentals/logging>
* <xref:fundamentals/error-handling>&dagger;

&dagger;S‚Äôapplique aux applications ASP.NET Core c√¥t√© serveur qui sont des applications principales d‚ÄôAPI Web pour les Blazor applications.

::: zone-end
